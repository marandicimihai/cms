@using System.Globalization
@using Ardalis.Result
@using CMS.Main.Abstractions.Properties.PropertyTypes
@using CMS.Main.Components.Shared.PropertyInputs
@using CMS.Main.DTOs
@using CMS.Main.Models
@using CMS.Main.Services.SchemaProperties
@using Humanizer
@using Mapster
@using Mono.TextTemplating

@inject IPropertyValidator SchemaPropertyValidator

<div class="flex flex-col gap-1">
    <label class="text-xs uppercase tracking-wide text-neutral-400" for="field-@Property.Id">
        @Property.Name
        @if (Property.IsRequired)
        {
            <span class="text-rose-600">*</span>
        }
    </label>
    <div class="flex items-center gap-4">
        <div class="flex-1">
            @switch (Property.Type)
            {
                case PropertyType.Text:
                    <TextPropertyInput 
                        Property="Property" InitialValue="@InitialValue" @ref="Input" ValueChanged="OnInputChanged" />
                    break;
                case PropertyType.Number:
                    <NumberPropertyInput 
                        Property="Property" InitialValue="@InitialValue" @ref="Input" ValueChanged="OnInputChanged" />
                    break;
                case PropertyType.Boolean:
                    <BooleanPropertyInput 
                        Property="Property" InitialValue="@InitialValue" @ref="Input" ValueChanged="OnInputChanged" />
                    break;
                case PropertyType.DateTime:
                    <DateTimePropertyInput 
                        Property="Property" InitialValue="@InitialValue" @ref="Input" ValueChanged="OnInputChanged" />
                    break;
                case PropertyType.Enum:
                    <EnumPropertyInput 
                        Property="Property" InitialValue="@InitialValue" @ref="Input" ValueChanged="OnInputChanged" />
                    break;
                default:
                    <div class="text-rose-600 text-sm">Unsupported type: @Property.Type</div>
                    break;
            }
        </div>
        @if (!Property.IsRequired)
        {
            <div class="flex items-center gap-2">
                <input id="toggle-@Property.Id" type="checkbox" class="h-4 w-4 rounded border-neutral-600 text-purple-500 focus:ring-purple-500" checked="@IsNull" @onchange="OnIsNullChanged" aria-label="Enable field" />
                <label class="text-xs text-neutral-400" for="toggle-@Property.Id">null</label>
            </div>
        }
    </div>
    @if (HasError)
    {
        <span class="text-rose-600 text-xs mt-1" role="alert">@ValidationMessage</span>
    }
</div>

<div class="hidden bg-slate-100 text-slate-500 cursor-not-allowed"></div>

@code {

    [Parameter, EditorRequired]
    public PropertyDto Property { get; set; } = default!;

    private PropertyDto PropertyCopy = default!;

    [Parameter]
    public object? InitialValue { get; set; }

    private IPropertyInput Input { get; set; } = default!;

    private string? ValidationMessage { get; set; }
    private bool HasError => !string.IsNullOrEmpty(ValidationMessage);

    private bool IsNull { get; set; } = false;

    protected override void OnParametersSet()
    {
        PropertyCopy = Property.Adapt<PropertyDto>();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            IsNull = InitialValue is null && !Property.IsRequired;
            Input.SetDisabled(IsNull);
            StateHasChanged();
        }
    }

    private void OnIsNullChanged(ChangeEventArgs e)
    {
        IsNull = e.Value?.ToString() == "true" || e.Value is true;
        Input.SetDisabled(IsNull);
        if (IsNull)
        {
            ValidationMessage = null;
        }
        StateHasChanged();
    }

    private void OnInputChanged(object? value)
    {
        ValidationMessage = null;
        if (!IsNull) 
        {
            var temp = Property.IsRequired;
            Property.IsRequired = true; // Temporarily disable required validation to allow empty values

            var validationResult = SchemaPropertyValidator.ValidateAndCast(Property, value);

            Property.IsRequired = temp; // Restore original required setting

            if (validationResult.IsInvalid() && validationResult.ValidationErrors.Any())
            {
                ValidationMessage = validationResult.ValidationErrors.First().ErrorMessage;
            }
        }
    }

    public void Reset()
    {
        Input.Reset();
        IsNull = InitialValue is null && !Property.IsRequired;
        Input.SetDisabled(IsNull);
        StateHasChanged();
    }

    public (PropertyDto, object?) GetPropertyAndValue()
    {
        if (IsNull)
            return (Property, null);

        return (Property, Input.GetValue());
    }

    public bool IsValid()
    {
        ValidationMessage = null;
        if (!IsNull) 
        {
            var temp = Property.IsRequired;
            Property.IsRequired = true; // Temporarily disable required validation to allow empty values

            var validationResult = SchemaPropertyValidator.ValidateAndCast(Property, Input.GetValue());

            Property.IsRequired = temp; // Restore original required setting

            if (validationResult.IsInvalid() && validationResult.ValidationErrors.Any())
            {
                ValidationMessage = validationResult.ValidationErrors.First().ErrorMessage;
            }
        }
        return !HasError;
    }

}