@using CMS.Main.Abstractions.Notifications
@using Microsoft.JSInterop
@implements IDisposable
@implements IAsyncDisposable
@rendermode InteractiveServer
@inject INotificationService NotificationService
@inject IJSRuntime JSRuntime

<div class="fixed bottom-4 right-4 z-50 flex flex-col gap-2" style="max-width: 400px;">
    @foreach (var notification in _notifications)
    {
        var bgColor = notification.Type switch
        {
            NotificationType.Success => "bg-emerald-600",
            NotificationType.Error => "bg-rose-600",
            NotificationType.Warning => "bg-amber-500",
            _ => "bg-blue-600"
        };

        var icon = notification.Type switch
        {
            NotificationType.Success => "check_circle",
            NotificationType.Error => "error",
            NotificationType.Warning => "warning",
            _ => "info"
        };

        <div class="@bgColor text-white rounded-lg shadow-lg p-4 flex items-start gap-3 @(notification.IsClosing ? "animate-slide-out" : "animate-slide-in")">
            <span class="material-symbols-outlined icons-default flex-shrink-0">@icon</span>
            <p class="text-sm flex-1">@notification.Message</p>
            <SecondaryButton Type="button" Variant="ButtonVariant.Neutral" Icon="close" @onclick="() => RemoveNotification(notification.Id)" aria-label="Close notification" />
        </div>
    }
</div>

@code {
    private List<NotificationItem> _notifications = new();
    private DotNetObjectReference<NotificationPopUp>? _dotNetReference;
    private IJSObjectReference? _jsModule;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetReference = DotNetObjectReference.Create(this);
        }
    }

    protected override void OnInitialized()
    {
        NotificationService.OnNotify += HandleNotification;
    }

    private async void HandleNotification(Notification notification)
    {
        var notificationItem = new NotificationItem
        {
            Id = Guid.NewGuid(),
            Message = notification.Message,
            Type = notification.Type
        };

        _notifications.Add(notificationItem);
        await InvokeAsync(StateHasChanged);

        // Schedule auto-removal after 4 seconds using JS
        if (_dotNetReference != null)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync(
                    "notificationManager.scheduleRemoval",
                    notificationItem.Id.ToString(),
                    4000,
                    _dotNetReference
                );
            }
            catch (Exception)
            {
                // JS interop might fail if component is disposing
            }
        }
    }

    [JSInvokable]
    public async Task RemoveNotificationFromJs(string notificationId)
    {
        if (Guid.TryParse(notificationId, out var id))
        {
            await RemoveNotification(id);
        }
    }

    private async Task RemoveNotification(Guid id)
    {
        var notification = _notifications.FirstOrDefault(n => n.Id == id);
        if (notification != null && !notification.IsClosing)
        {
            notification.IsClosing = true;
            await InvokeAsync(StateHasChanged);
            
            // Wait for exit animation (300ms) before removing
            await Task.Delay(300);
            
            _notifications.Remove(notification);
            await InvokeAsync(StateHasChanged);

            // Cancel any scheduled removal for this notification
            try
            {
                await JSRuntime.InvokeVoidAsync(
                    "notificationManager.cancelRemoval",
                    id.ToString()
                );
            }
            catch (Exception)
            {
                // JS interop might fail if component is disposing
            }
        }
    }

    public void Dispose()
    {
        NotificationService.OnNotify -= HandleNotification;
        _dotNetReference?.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        Dispose();
        
        // Clear all scheduled removals
        try
        {
            await JSRuntime.InvokeVoidAsync("notificationManager.clearAll");
        }
        catch (Exception)
        {
            // JS interop might fail if already disposed
        }

        if (_jsModule != null)
        {
            await _jsModule.DisposeAsync();
        }
    }

    private class NotificationItem
    {
        public Guid Id { get; set; }
        public string? Message { get; set; }
        public NotificationType Type { get; set; }
        public bool IsClosing { get; set; }
    }
}

